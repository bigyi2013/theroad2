waitKey(x);
第一个参数： 等待x ms，如果在此期间有按键按下，则立即结束并返回按下按键的
ASCII码，否则返回-1
如果x=0，那么无限等待下去，直到有按键按下

命令参数 left5.bmp right5.bmp --algorithm=sgbm --blocksize=5 --max-disparity=256  --scale=1.0 -i intrinsics.yml -e extrinsics.yml -o disparity.bmp


CopyMakeBorder
复制图像并且制作边界。（处理边界卷积）
void cvCopyMakeBorder( const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value=cvScalarAll(0) );
src
输入图像。
dst
输出图像。
offset
输入图像（或者其ROI）欲拷贝到的输出图像长方形的左上角坐标（或者左下角坐标，如果以左下角为原点）。长方形的尺寸要和原图像的尺寸的ROI分之一匹配。
bordertype
已拷贝的原图像长方形的边界的类型：
IPL_BORDER_CONSTANT - 填充边界为固定值，值由函数最后一个参数指定。IPL_BORDER_REPLICATE -边界用上下行或者左右列来复制填充。（其他两种IPL边界类型， IPL_BORDER_REFLECT 和IPL_BORDER_WRAP现已不支持）。
value
如果边界类型为IPL_BORDER_CONSTANT的话，那么此为边界像素的值。
函数cvCopyMakeBorder拷贝输入2维阵列到输出阵列的内部并且在拷贝区域的周围制作一个指定类型的边界。函数可以用来模拟和嵌入在指定算法实现中的边界不同的类型。例如：和opencv中大多数其他滤波函数一样，一些形态学函数内部使用复制边界类型，但是用户可能需要零边界或者填充为1或255的边界。

普通构造函数能够被隐式调用。而explicit构造函数只能被显式调用。

你想通过<< 这个操作符直接输出你所创建的类的实例（对象），而<< 操作符属于iostream库，这个库无法识别你自己定义的类，因而需要对操作符<< 重载。
重载<< 函数返回类型是一个流的引用， 第一个参数是流，第二个参数是以引用传递的方式的一个类的实例（并且只能对这个参数读操作）

createTrackbar
int createTrackbar(conststring& trackbarname, conststring& winname,  
 int* value, int count, TrackbarCallback onChange=0,void* userdata=0); 
 第一个参数，const string&类型的trackbarname，表示轨迹条的名字，用来代表我们创建的轨迹条。
第二个参数，const string&类型的winname，填窗口的名字，表示这个轨迹条会依附到哪个窗口上，即对应namedWindow（）创建窗口时填的某一个窗口名。
第三个参数，int* 类型的value，一个指向整型的指针，表示滑块的位置。并且在创建时，滑块的初始位置就是是由该变量当前的值。
第四个参数，int类型的count，表示滑块可以达到的最大位置的值。PS:滑块最小的位置的值始终为0。
第五个参数，TrackbarCallback类型的onChange，首先注意他有默认值0。这是一个指向回调函数的指针，每次滑块位置改变时，这个函数都会进行回调。并且这个函数的原型必须为void XXXX(int,void*);其中第一个参数是轨迹条的位置，第二个参数是用户数据（看下面的第六个参数）。如果回调是NULL指针，表示没有回调函数的调用，仅第三个参数value有变化。
第六个参数，void*类型的userdata，他也有默认值0。这个参数是用户传给回调函数的数据，用来处理轨迹条事件。如果使用的第三个参数value实参是全局变量的话，完全可以不去管这个userdata参数。
获取当前轨迹条的位置――getTrackbarPos函数

Mat类下如何设置ROI？

Mat image;
Rect roi(x, y, w, h);
Mat roi_of_image = image(roi);


Mat img;
        img = imread("deep.jpg", 1);
        Rect roi(0, 0, 100, 100);
        Mat face_mask(img.rows, img.cols, img.type());
        cvZero(&IplImage(face_mask));
        Point left_up, right_down;
        left_up.x = cvRound((roi.x));
        left_up.y = cvRound((roi.y));
        right_down.x = cvRound((roi.x + roi.width));
        right_down.y = cvRound((roi.y + roi.height));
        rectangle(face_mask, left_up, right_down, cvScalar(255,255,255), CV_FILLED);
        Mat copy_to；
        img.copyTo(copy_to, face_mask);
        imshow("face_mask", face_mask);
        imshow("img", img);
        imshow("copy_to", copy_to);
        imshow("roi_of_img", roi_of_img);
        cvWaitKey();
		
int main() {
    Mat srcImage = imread("deep.jpg");
    imshow("【原图】", srcImage);
    Mat logoImage = imread("poster_dota_logo.jpg");
    Mat imageROI = srcImage(Rect(200, 250, logoImage.cols, logoImage.rows));

//  Mat mask = Mat::zeros(logoImage.cols, logoImage.rows, CV_8UC1);  //模板为单通道即可
    Mat mask = Mat::ones(logoImage.cols, logoImage.rows, CV_8UC1);
    logoImage.copyTo(imageROI, mask);
    imshow("【利用ROI实现图像叠加示例窗口】", srcImage);

    waitKey(6000);
    return 0;
}

xiaoyouFTP124